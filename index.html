<!DOCTYPE html>
<html>
  <head>
    <title>Game of Life</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #f4f4f4;
      }
      #game-of-life-canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="game-of-life-canvas"></canvas>
    <script>
      class CanvasRenderer {
        constructor(game, cellSize) {
          this.cellSize = cellSize;
          this.game = game;
          this.canvas = document.querySelector('#game-of-life-canvas');
          this.context = this.canvas.getContext('2d');
          this.canvas.height = window.innerHeight * 0.9;
          this.canvas.width = window.innerWidth * 0.9;
        }

        draw() {
          this.clear();
          this.drawRows();
          this.drawColumns();
          this.drawGame();
        }

        clear() {
          this.context.fillStyle = '#f4f4f4';
          this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        drawRows() {
          for (
            let y = this.cellSize;
            y < this.canvas.height;
            y += this.cellSize
          ) {
            this.context.beginPath();
            this.context.moveTo(0, y);
            this.context.lineTo(this.canvas.width, y);
            this.context.stroke();
          }
        }

        drawColumns() {
          this.context.strokeStyle = '#ccc';
          for (
            let x = this.cellSize;
            x < this.canvas.width;
            x += this.cellSize
          ) {
            this.context.beginPath();
            this.context.moveTo(x, 0);
            this.context.lineTo(x, this.canvas.height);
            this.context.stroke();
          }
        }

        drawGame() {
          this.context.fillStyle = '#000';
          this.game.livingCells.forEach((cell) => {
            const [x, y] = Cell.keyToCoordinate(cell);
            this.context.fillRect(
              x * this.cellSize,
              y * this.cellSize,
              this.cellSize,
              this.cellSize
            );
          });
        }
      }

      class LifeBoard {
        constructor(livingCell) {
          this.livingCells = new Set(livingCell);
        }

        neighbors(x, y) {
          return [
            new Cell(x - 1, y + 1),
            new Cell(x, y + 1),
            new Cell(x + 1, y + 1),
            new Cell(x + 1, y),
            new Cell(x + 1, y - 1),
            new Cell(x, y - 1),
            new Cell(x - 1, y - 1),
            new Cell(x - 1, y),
          ];
        }

        nextGeneration() {
          const livingNeighbors = new Map();

          this.livingCells.forEach((key) => {
            const [x, y] = Cell.keyToCoordinate(key);

            this.neighbors(x, y).forEach((neighbor) => {
              const neighborKey = neighbor.key();
              livingNeighbors.set(
                neighborKey,
                (livingNeighbors.get(neighborKey) || 0) + 1
              );
            });
          });

          const newLivingNeighbors = new Set();
          livingNeighbors.forEach((count, key) => {
            const isAlive = this.livingCells.has(key);
            if (count === 3 || (isAlive && count == 2)) {
              newLivingNeighbors.add(key);
            }
          });

          this.livingCells = newLivingNeighbors;
        }
      }

      class Cell {
        static CELL_SEPARATOR = '_';

        constructor(x, y) {
          this.x = x;
          this.y = y;
        }

        key() {
          return this.x + Cell.CELL_SEPARATOR + this.y;
        }

        static keyToCoordinate(key) {
          return key.split(Cell.CELL_SEPARATOR).map(Number);
        }
      }

      class CellPatternFactory {
        chaos(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(1, 0)
            .addCell(0, 1)
            .addCell(1, 1)
            .addCell(1, 2)
            .addCell(2, 2)
            .reverse()
            .inverse()
            .moveTo(offsetX, offsetY)
            .keys();
        }

        glider(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(0, 1)
            .addCell(1, 2)
            .addCell(2, 0)
            .addCell(2, 1)
            .addCell(2, 2)
            .moveTo(offsetX, offsetY)
            .keys();
        }

        blinker(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(0, 1)
            .addCell(1, 1)
            .addCell(2, 1)
            .moveTo(offsetX, offsetY)
            .keys();
        }

        beacon(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(0, 0)
            .addCell(0, 1)
            .addCell(1, 0)
            .addCell(2, 3)
            .addCell(3, 2)
            .addCell(3, 3)
            .moveTo(offsetX, offsetY)
            .keys();
        }

        toad(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(1, 1)
            .addCell(2, 1)
            .addCell(3, 1)
            .addCell(0, 2)
            .addCell(1, 2)
            .addCell(2, 2)
            .moveTo(offsetX, offsetY)
            .keys();
        }

        warship(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(1, 1)
            .addCell(2, 1)
            .addCell(3, 1)
            .addCell(4, 1)
            .addCell(5, 1)
            .addCell(0, 2)
            .addCell(5, 2)
            .addCell(5, 3)
            .addCell(4, 4)
            .moveTo(offsetX, offsetY)
            .keys();
        }

        pulsar(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(2, 0)
            .addCell(3, 0)
            .addCell(4, 0)
            .addCell(8, 0)
            .addCell(9, 0)
            .addCell(10, 0)
            .addCell(0, 2)
            .addCell(5, 2)
            .addCell(7, 2)
            .addCell(12, 2)
            .addCell(0, 3)
            .addCell(5, 3)
            .addCell(7, 3)
            .addCell(12, 3)
            .addCell(0, 4)
            .addCell(5, 4)
            .addCell(7, 4)
            .addCell(12, 4)
            .addCell(2, 5)
            .addCell(3, 5)
            .addCell(4, 5)
            .addCell(8, 5)
            .addCell(9, 5)
            .addCell(10, 5)
            .addCell(2, 7)
            .addCell(3, 7)
            .addCell(4, 7)
            .addCell(8, 7)
            .addCell(9, 7)
            .addCell(10, 7)
            .addCell(0, 8)
            .addCell(5, 8)
            .addCell(7, 8)
            .addCell(12, 8)
            .addCell(0, 9)
            .addCell(5, 9)
            .addCell(7, 9)
            .addCell(12, 9)
            .addCell(0, 10)
            .addCell(5, 10)
            .addCell(7, 10)
            .addCell(12, 10)
            .addCell(2, 12)
            .addCell(3, 12)
            .addCell(4, 12)
            .addCell(8, 12)
            .addCell(9, 12)
            .addCell(10, 12)
            .moveTo(offsetX, offsetY)
            .keys();
        }
      }

      class CellPatternBuilder {
        constructor() {
          this.cells = [];
        }

        addCell(x, y) {
          this.cells.push(new Cell(x, y));
          return this;
        }

        moveTo(offsetX, offsetY) {
          this.cells = this.cells.map(
            (cell) => new Cell(cell.x + offsetX, cell.y + offsetY)
          );
          return this;
        }

        reverse() {
          this.cells = this.cells.map((cell) => new Cell(cell.y, cell.x));
          return this;
        }

        inverse() {
          this.cells = this.cells.map((cell) => new Cell(cell.x, -cell.y));
          return this;
        }

        keys() {
          return this.cells.map((cell) => cell.key());
        }
      }

      class GameOfLife {
        static self;
        fps = 10;

        run() {
          const cellPatternFactory = new CellPatternFactory();
          const gameoflife = new LifeBoard(cellPatternFactory.chaos(10, 10));
          const renderer = new CanvasRenderer(gameoflife, 30);

          setInterval(() => {
            renderer.draw();
            gameoflife.nextGeneration();
          }, GameOfLife.fpsToMilliseconds(this.fps));
        }

        static fpsToMilliseconds(fps) {
          return 1000 / fps;
        }

        static instance() {
          if (!this.self) {
            this.self = new GameOfLife();
          }
          return this.self;
        }
      }

      GameOfLife.instance().run();
    </script>
  </body>
</html>
