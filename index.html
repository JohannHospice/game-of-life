<!DOCTYPE html>
<html>
  <head>
    <title>Game of Life</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: rgb(6, 21, 33);
      }
      #game-of-life-canvas {
        /* border: 1px solid black; */
      }
    </style>
  </head>
  <body>
    <canvas id="game-of-life-canvas"></canvas>
    <script>
      class GameOfLife {
        static running = false;
        static self;
        fps = 15;
        cellSize = 10;

        constructor() {
          const cellPatternFactory = new CellPatternFactory();
          this.lifeBoard = new LifeBoard(cellPatternFactory.face(100, 60));
          this.renderer = new CanvasRenderer(
            '#game-of-life-canvas',
            this.lifeBoard,
            this.cellSize
          );
        }

        run() {
          if (GameOfLife.running) {
            return;
          }
          GameOfLife.running = true;

          setInterval(() => {
            this.renderer.draw();
            this.lifeBoard.nextGeneration();
          }, GameOfLife.fpsToMilliseconds(this.fps));
        }

        static fpsToMilliseconds(fps) {
          return 1000 / fps;
        }

        static instance() {
          if (!this.self) {
            this.self = new GameOfLife();
          }
          return this.self;
        }
      }

      class CanvasRenderer {
        backgroundColor = 'rgba(6, 21, 33, 0.6)';
        strokeColor = 'transparent';
        cellColor = '#D07071';

        constructor(id, game, cellSize) {
          this.game = game;
          this.cellSize = cellSize;
          this.canvas = document.querySelector(id);
          this.context = this.canvas.getContext('2d');
          this.canvas.height = window.innerHeight;
          this.canvas.width = window.innerWidth;
        }

        draw() {
          this.clear();
          this.drawRows();
          this.drawColumns();
          this.drawGame();
        }

        clear() {
          this.context.fillStyle = this.backgroundColor;
          this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        drawRows() {
          this.context.strokeStyle = this.strokeColor;
          for (
            let y = this.cellSize;
            y < this.canvas.height;
            y += this.cellSize
          ) {
            this.context.beginPath();
            this.context.moveTo(0, y);
            this.context.lineTo(this.canvas.width, y);
            this.context.stroke();
          }
        }

        drawColumns() {
          this.context.strokeStyle = this.strokeColor;
          for (
            let x = this.cellSize;
            x < this.canvas.width;
            x += this.cellSize
          ) {
            this.context.beginPath();
            this.context.moveTo(x, 0);
            this.context.lineTo(x, this.canvas.height);
            this.context.stroke();
          }
        }

        drawGame() {
          this.context.fillStyle = this.cellColor;
          this.game.livingCells.forEach((cell) => {
            const [x, y] = Cell.keyToCoordinate(cell);
            this.context.fillRect(
              x * this.cellSize,
              y * this.cellSize,
              this.cellSize,
              this.cellSize
            );
          });
        }
      }

      class LifeBoard {
        constructor(livingCell) {
          this.livingCells = new Set(livingCell);
        }

        nextGeneration() {
          const countLivingNeighborsPerCell = new Map();

          this.livingCells.forEach((key) => {
            const [x, y] = Cell.keyToCoordinate(key);

            new CellPatternFactory().neighbors(x, y).forEach((neighborKey) => {
              countLivingNeighborsPerCell.set(
                neighborKey,
                (countLivingNeighborsPerCell.get(neighborKey) || 0) + 1
              );
            });
          });

          const newLivingCells = new Set();
          countLivingNeighborsPerCell.forEach((count, key) => {
            const isAlive = this.livingCells.has(key);
            if (count === 3 || (isAlive && count == 2)) {
              newLivingCells.add(key);
            }
          });

          this.livingCells = newLivingCells;
        }
      }

      class Cell {
        static CELL_SEPARATOR = '_';

        constructor(x, y) {
          this.x = x;
          this.y = y;
        }

        key() {
          return this.x + Cell.CELL_SEPARATOR + this.y;
        }

        static keyToCoordinate(key) {
          return key.split(Cell.CELL_SEPARATOR).map(Number);
        }
      }

      class CellPatternFactory {
        simplePattern(offsetX, offsetY) {
          const patternA = new CellPatternBuilder()
            .addCell(0, 1)
            .addCell(1, 0)
            .addCell(2, 0)
            .addCell(3, 0)
            .addCell(3, 1)
            .addCell(3, 2)
            .addCell(3, 3)
            .addCell(2, 4);

          return new CellPatternBuilder()
            .addPattern(patternA.cells)
            .addPattern(
              new CellPatternBuilder()
                .addCell(0, 2)
                .addCell(1, 1)
                .addCell(1, 0)
                .addCell(2, 0)
                .addCell(3, 0)
                .addCell(4, 1)
                .moveTo(7, 2).cells
            )
            .addPattern(patternA.moveTo(14, 0).cells)
            .inverse()
            .moveTo(offsetX, offsetY)
            .keys();
        }

        neighbors(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(-1, 1)
            .addCell(0, 1)
            .addCell(1, 1)
            .addCell(1, 0)
            .addCell(1, -1)
            .addCell(0, -1)
            .addCell(-1, -1)
            .addCell(-1, 0)
            .moveTo(offsetX, offsetY)
            .keys();
        }
        face(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(0, 0)
            .addCell(0, 1)
            .addCell(0, 2)
            .addCell(1, 1)
            .addCell(1, 3)
            .addCell(2, 4)
            .addCell(3, 3)
            .addCell(4, 2)
            .addCell(4, 1)
            .addCell(4, 0)
            .addCell(3, 1)
            .addCell(2, 2)
            .moveTo(offsetX, offsetY)
            .keys();
        }

        chaos(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(1, 0)
            .addCell(0, 1)
            .addCell(1, 1)
            .addCell(1, 2)
            .addCell(2, 2)
            .reverse()
            .inverse()
            .moveTo(offsetX, offsetY)
            .keys();
        }
        perpetualgun(offsetX, offsetY) {
          return (
            new CellPatternBuilder()
              // Première partie du pattern
              .addCell(21, 0)
              .addCell(23, 0)
              .addCell(20, 1)
              .addCell(24, 1)
              .addCell(19, 2)
              .addCell(25, 2)
              .addCell(19, 3)
              .addCell(25, 3)
              .addCell(19, 4)
              .addCell(25, 4)
              .addCell(20, 5)
              .addCell(24, 5)
              .addCell(21, 6)
              .addCell(23, 6)

              // Seconde partie du pattern
              .addCell(11, 2)
              .addCell(12, 2)
              .addCell(11, 3)
              .addCell(12, 3)

              // Troisième partie du pattern
              .addCell(9, 10)
              .addCell(10, 10)
              .addCell(9, 11)
              .addCell(11, 11)
              .addCell(9, 12)
              .addCell(12, 12)

              // Quatrième partie du pattern
              .addCell(19, 14)
              .addCell(25, 14)
              .addCell(20, 15)
              .addCell(24, 15)
              .addCell(21, 16)
              .addCell(23, 16)

              // Déplacement du pattern à l'offset
              .moveTo(offsetX, offsetY)
              .keys()
          );
        }
        alternatewickstretcher1(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(26, 0) // Ligne 1
            .addCell(26, 1)
            .addCell(27, 1) // Ligne 2
            .addCell(10, 2)
            .addCell(25, 2)
            .addCell(28, 2) // Ligne 3
            .addCell(9, 3)
            .addCell(28, 3) // Ligne 4
            .addCell(2, 4)
            .addCell(4, 4)
            .addCell(8, 4)
            .addCell(22, 4)
            .addCell(25, 4) // Ligne 5
            .addCell(1, 5)
            .addCell(4, 5)
            .addCell(7, 5)
            .addCell(11, 5)
            .addCell(14, 5)
            .addCell(18, 5)
            .addCell(22, 5) // Ligne 6
            .addCell(1, 6)
            .addCell(4, 6)
            .addCell(7, 6)
            .addCell(8, 6)
            .addCell(17, 6)
            .addCell(20, 6)
            .addCell(25, 6) // Ligne 7
            .addCell(2, 7)
            .addCell(4, 7)
            .addCell(7, 7)
            .addCell(11, 7)
            .addCell(14, 7)
            .addCell(17, 7)
            .addCell(18, 7)
            .addCell(19, 7) // Ligne 8
            .addCell(2, 8)
            .addCell(7, 8)
            .addCell(10, 8)
            .addCell(14, 8)
            .addCell(16, 8)
            .addCell(17, 8)
            .addCell(25, 8) // Ligne 9
            .addCell(1, 9)
            .addCell(4, 9)
            .addCell(7, 9)
            .addCell(9, 9)
            .addCell(14, 9)
            .addCell(16, 9)
            .addCell(19, 9)
            .addCell(22, 9) // Ligne 10
            .addCell(2, 10)
            .addCell(4, 10)
            .addCell(7, 10)
            .addCell(14, 10)
            .addCell(22, 10) // Ligne 11
            .addCell(5, 11)
            .addCell(9, 11)
            .addCell(13, 11)
            .addCell(16, 11)
            .addCell(21, 11) // Ligne 12
            .addCell(5, 12)
            .addCell(8, 12)
            .addCell(13, 12)
            .addCell(15, 12)
            .addCell(20, 12) // Ligne 13
            .addCell(8, 13)
            .addCell(12, 13)
            .addCell(14, 13)
            .addCell(16, 13) // Ligne 14
            .addCell(15, 14)
            .addCell(19, 14) // Ligne 15
            .addCell(13, 15)
            .addCell(19, 15) // Ligne 16
            .addCell(17, 16)
            .addCell(22, 16) // Ligne 17
            .addCell(16, 17)
            .addCell(20, 17)
            .addCell(22, 17) // Ligne 18
            .addCell(22, 19) // Ligne 20
            .moveTo(offsetX, offsetY)
            .keys();
        }
        glider(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(0, 1)
            .addCell(1, 2)
            .addCell(2, 0)
            .addCell(2, 1)
            .addCell(2, 2)
            .moveTo(offsetX, offsetY)
            .keys();
        }

        blinker(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(0, 1)
            .addCell(1, 1)
            .addCell(2, 1)
            .moveTo(offsetX, offsetY)
            .keys();
        }

        beacon(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(0, 0)
            .addCell(0, 1)
            .addCell(1, 0)
            .addCell(2, 3)
            .addCell(3, 2)
            .addCell(3, 3)
            .moveTo(offsetX, offsetY)
            .keys();
        }

        toad(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(1, 1)
            .addCell(2, 1)
            .addCell(3, 1)
            .addCell(0, 2)
            .addCell(1, 2)
            .addCell(2, 2)
            .moveTo(offsetX, offsetY)
            .keys();
        }

        warship(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(1, 1)
            .addCell(2, 1)
            .addCell(3, 1)
            .addCell(4, 1)
            .addCell(5, 1)
            .addCell(0, 2)
            .addCell(5, 2)
            .addCell(5, 3)
            .addCell(4, 4)
            .moveTo(offsetX, offsetY)
            .keys();
        }

        pulsar(offsetX, offsetY) {
          return new CellPatternBuilder()
            .addCell(2, 0)
            .addCell(3, 0)
            .addCell(4, 0)
            .addCell(8, 0)
            .addCell(9, 0)
            .addCell(10, 0)
            .addCell(0, 2)
            .addCell(5, 2)
            .addCell(7, 2)
            .addCell(12, 2)
            .addCell(0, 3)
            .addCell(5, 3)
            .addCell(7, 3)
            .addCell(12, 3)
            .addCell(0, 4)
            .addCell(5, 4)
            .addCell(7, 4)
            .addCell(12, 4)
            .addCell(2, 5)
            .addCell(3, 5)
            .addCell(4, 5)
            .addCell(8, 5)
            .addCell(9, 5)
            .addCell(10, 5)
            .addCell(2, 7)
            .addCell(3, 7)
            .addCell(4, 7)
            .addCell(8, 7)
            .addCell(9, 7)
            .addCell(10, 7)
            .addCell(0, 8)
            .addCell(5, 8)
            .addCell(7, 8)
            .addCell(12, 8)
            .addCell(0, 9)
            .addCell(5, 9)
            .addCell(7, 9)
            .addCell(12, 9)
            .addCell(0, 10)
            .addCell(5, 10)
            .addCell(7, 10)
            .addCell(12, 10)
            .addCell(2, 12)
            .addCell(3, 12)
            .addCell(4, 12)
            .addCell(8, 12)
            .addCell(9, 12)
            .addCell(10, 12)
            .moveTo(offsetX, offsetY)
            .keys();
        }
      }

      class CellPatternBuilder {
        constructor() {
          this.cells = [];
        }

        addCell(x, y) {
          this.cells.push(new Cell(x, y));
          return this;
        }

        addPattern(pattern) {
          this.cells = this.cells.concat(pattern);
          return this;
        }

        moveTo(offsetX, offsetY) {
          this.cells = this.cells.map(
            (cell) => new Cell(cell.x + offsetX, cell.y + offsetY)
          );
          return this;
        }

        reverse() {
          this.cells = this.cells.map((cell) => new Cell(cell.y, cell.x));
          return this;
        }

        inverse() {
          this.cells = this.cells.map((cell) => new Cell(cell.x, -cell.y));
          return this;
        }

        keys() {
          return this.cells.map((cell) => cell.key());
        }
      }

      GameOfLife.instance().run();
    </script>
  </body>
</html>
